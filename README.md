## 1
### TDD基本原则
- 当且仅当存在失败的自动化测试时，才开始编写生产代码
- 消除坏味道

### 测试驱动开发咒语
- 红/绿/重构
  - 红: 编写一个失败的测试，甚至是无法编译的测试
  - 绿: 让这个测试快速通过，甚至不惜犯下任何罪恶
  - 重构: 消除上一步中产生的坏味道

### 红绿重构的劣势
- 红绿重构循环仅仅关注单个测试，并未回答测试从何而来。

### 任务分解
- 大致构思软件被使用的方式，把握对外接口的方向
- 大致构思功能的实现方式，划分所需组件以及组件间的关系（所谓的架构）。当然，如果没思路，也可以不划分
- 根据需求的功能描述拆分功能点，功能点要考虑happy path 和 sad path
- 依照组件以及组件之间的关系，将功能拆分到对应组件
- 针对拆分的结果编写测试，进入红绿重构循环

### TDD工作流程
<img width="538" alt="image" src="https://user-images.githubusercontent.com/99648697/164592422-fd231a71-6c7a-417d-ac8d-f19737969053.png">


### 问题思考
如果在思考实现策略的时候，我们选择了其他的实现方式，那么任务分解会有什么不同？

## 2
### 问题思考
- 什么时候开始重构
  - 测试都是绿的
  - 坏味道足够明显
- 重构有哪些坏味道，使用了哪些模式？
    分支语句、代码重复；利用多态替换条件分支+抽象工厂、抽象+使用函数作为构造方法参数来处理差异
- 这里重构有几步？
    抽方法、定义接口、实现接口、替换方法、inline方法、分离步骤为创建+执行、将创建使用工厂
- 重构时，如果先消除重复，在重构步骤上会有什么不同吗？
    会不同，如果先消除重复，则会先抽取方法，然后再对重复方法里面的逻辑做修改

## 5
### 测试结构
<img width="533" alt="image" src="https://user-images.githubusercontent.com/99648697/164595231-9076a2ee-866d-4d43-ae2a-8242cfceaea1.png">
### 测试验证
- 状态验证
    状态验证是指在与待测系统交互后，通过比对测试上下文与待测系统的状态变化，判断待测系统是否满足需求的验证方式
    状态验证是一种黑盒验证，它将测试上下文与待测系统当作一个整体
- 行为验证
    行为验证是指通过待测系统与依赖组件（Depended On Component）的交互，来判断待测系统是否满足需求的验证方式
    行为验证背后的逻辑是，状态的改变是由交互引起的。如果所有的交互都正确，那么就可以推断最终的状态也不会错
    分离组件的白盒验证
    旨在降低测试成本
    
### 问题思考
- 为什么 TDD 中主要使用状态验证来验证测试的结果？
    行为验证的逻辑是通过测试功能是如何实现的，来推断结果是否正确。换句话说，行为验证本身并不能验证功能是否正确，而只能验证功能是否按照某种方式实现。如果按照某种方式实现，那么就可以推测出功能是正确的。这与TDD的核心逻辑就冲突了。在TDD的红/绿/重构中，重构要求在功能不变的前提下，改变实现方式。而对于行为验证而言，实现方式改变就是功能改变。因而重构就无法进行！需要重写！也就是说，行为验证会阻碍TDD的进行


